
Somehow the sensordata needs to find its way into the control loops of the autopilot.
We have established that i2c is the hardware solution to transmit the data.

Now it is important to pin down in which way the measurements get triggert and when and how the result is transmitted back.

\section{Communication Protocol}

There are two possible ways to talk to the sensor.
You can define independent commands to start a measurement and retrieve data.
The obvious disatvantage of this method is, that there is a bit of communication overhead and the master device won't read the data from the sensor as soon as it is possible—the master might event start a new measurement without even reading the result at all.

The other way to do things is that the slave device writes the data onto the bus as soon as it is arriving.
This way of sending results however has disatvantages that ar e far worse then reading measurements a bit later and even missing some measurements.
Those disatvantages are caused by the way i2c handles slave writes.

The sensor has different functions described by i2c-registers that can be written to by the master device.
The registers and the format of the range response are described by \emph{i2c\_interface.h}.


\begin{table}
	
	\begin{tabularx}{\columnwidth}{l | l | X}
	Byte & Name & Description \\ \hline
	0x0  & ECHO & return payload byte\\
	0x1  & START\_RANGING & trigger range measurement\\
	0x3  & START\_REMOTE\_RANGING & trigger remote measurement\\
	0x2  & READ\_LAST\_RANGING & read measured distance\\
	0xFE & SET\_I2C\_ADDRESS & set new i2c address\\
	0xFD & SET\_SHORT\_ADDRESS & set new ranging short address\\
	0xFC & SET\_REFLECTOR\_ADDRESS & set reflector address\\
	0xFB & SET\_INITIATOR\_ADDRESS & set initiator address\\
	0xED & GET\_SHORT\_ADDRESS & get ranging address\\
	0xEC & GET\_REFLECTOR\_ADDRESS & get reflector address\\
	0xEB & GET\_INITIATOR\_ADDRESS & get initiator address\\
	0xFF & CLEAR\_BUFFER & clear i2c write buffer\\
	0xCA & SET\_FREQ\_START & set lower ranging frequency\\
	0xCB & SET\_FREQ\_STEP & set ranging frequency spacing\\
	0xCC & I2C\_SET\_FREQ\_STOP & set upper frequency\\
	0xCD & SET\_DIVERSITY & turn on/off antenna bdiversity\\
	\end{tabularx}

	\caption{Implemented I2C-Commands and Description}
	
\end{table}

Another design decision that has to be made is how the data structure for ranging results should look like.
\todo{status, dqf, range, addresses, message id}
Obviously the measured distance needs to be included in the message, but instead of the original 32-Bit value only a 16-Bit value is used, as distances up to more than \SI{60}{\metre} can be expressed that way.

The dqf value also needs to be transmitted, as the sensor node can not decide in wich way the values should be used by the master device, i.e. making application dependent filtering more accurate\footnote{
	An application were the dqf-value is of much use is a Kalman-State-Filter, which could gain accuracy by using the dqf value to estimate the reliability of the range values.
}.
In secenarios with multiple ranging nodes or remote ranging the addresses of both nodes taking part in the range measurement also need to be included into the message.
This information enables the master device to assign the range values to the right pair of devices, even if one of the messages gets lost or the order of measurements changes.

Depending on the setup the sensor nodes do not communicate measurement failures, but retransmit the old values again.
As a consequence two more values should be transmitted: The status of the measurement and a message id.
Those values enable the client to discard erroneous measurements and duplicate readings. 


\todo{"TWI", "Phillips-I2C", "..."}

\section{Paparazzi Module for Ranging}

\todo{Treiber für  Ranging}
\todo{(optional)Treiber für Pseudo GPS}

Addressing is done using the unique aircraft id of the indivdual robots.
Because the short addresses for the ranging nodes are 16 bit long and the aircraft ids are 8 bit values it is feasable to use a fixed prefix together with the ac-id as node addresses.

\section{Python Scripts}

For testing the sensor nodes and also for aquiering the data for evaluating the sensors I set up a RapsberryPi minicomputer as i2c master.
Using this setup for testing has proven really effective even before integrating attaching the sensor nodes to one of the finken robots.
Python might also be a very powerfull tool to prototype mathematical processing of the sensor inputs like filtering and fusion of different ranging results.

\emph{i2cranging.py} contains functions for the master side of I2C communication. Those can either be used from the python PEPL or by other scripts.
\emph{poll\_range.py} contains a convenient method to take continous range readings from the unix shell and is mainly used to generate csv-files with ranging values.
