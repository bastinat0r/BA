
The basic idea for the firmware of the nodes is to provide an I2C interface to initiate measurements and read values.
Additionally the settings of the modules can be changed by the same interface.


\section{Communication Interface}



The sensor has different functions described by i2c-registers that can be written to by the master device.
The registers are described by \autoref{i2ccommands}.
In normal operation the master device will set reflector and initiator address, initiate the ranging and read the resulting range value afterwards.
Some functionality like changing the addresses and setup of the devices are provided as well.

\autoref{rangefields} describes how the structure for transmitting range values is organized.
The reason why so many values are included into the range measurement is that the master device is most propably needs to do filtering based on status and dqf-values. The addresses of the nodes are included to match measurements in case one of the packets is lost or a new measurement is made before the old value is read.
The data type for the range values is changed, not to block the i2c-device unnecessarily the data type of the range reading is changed.
Instead of the original 32-Bit value only a 16-Bit value is used, as distances up to more than \SI{60}{\metre} are more than plenty in our application.

\begin{table}
	
	\begin{tabularx}{\columnwidth}{l | l | X}
	Byte & Name & Description \\ \hline
	0x0  & ECHO & return payload byte\\
	0x1  & START\_RANGING & trigger range measurement\\
	0x3  & START\_REMOTE\_RANGING & trigger remote measurement\\
	0x2  & READ\_LAST\_RANGING & read measured distance\\
	0xFE & SET\_I2C\_ADDRESS & set new i2c address\\
	0xFD & SET\_SHORT\_ADDRESS & set new ranging short address\\
	0xFC & SET\_REFLECTOR\_ADDRESS & set reflector address\\
	0xFB & SET\_INITIATOR\_ADDRESS & set initiator address\\
	0xED & GET\_SHORT\_ADDRESS & get ranging address\\
	0xEC & GET\_REFLECTOR\_ADDRESS & get reflector address\\
	0xEB & GET\_INITIATOR\_ADDRESS & get initiator address\\
	0xFF & CLEAR\_BUFFER & clear i2c write buffer\\
	0xCA & SET\_FREQ\_START & set lower ranging frequency\\
	0xCB & SET\_FREQ\_STEP & set ranging frequency spacing\\
	0xCC & I2C\_SET\_FREQ\_STOP & set upper frequency\\
	0xCD & SET\_DIVERSITY & turn on/off antenna bdiversity\\
	\end{tabularx}

	\caption{Implemented I2C-Commands and Description}
	\label{i2ccommands}
	
\end{table}

\begin{table}
	
	\begin{tabularx}{\columnwidth}{l | l | X}
	Type & Name & Description \\ \hline
		uint8\_t  & status       & status of the range measurement \\
		uint8\_t  & dqf          & quality of the range reading \\
		uint16\_t & distance     & measured distance \\
		uint16\_t & short\_addr1 & initiator address \\
		uint16\_t & short\_addr2 & reflector address \\
	\end{tabularx}

	\caption{Fields included in one range measurement}
	\label{rangefields}
	
\end{table}



\todo{"TWI", "Phillips-I2C", "..."}

%\section{Paparazzi Module for Ranging}
%
%\todo{Treiber für  Ranging}
%\todo{(optional)Treiber für Pseudo GPS}
%
%Addressing is done using the unique aircraft id of the indivdual robots.
%Because the short addresses for the ranging nodes are 16 bit long and the aircraft ids are 8 bit values it is feasable to use a fixed prefix together with the ac-id as node addresses.

\section{Python Scripts}

For testing the sensor nodes and also for aquiering the data for evaluating the sensors I set up a RapsberryPi minicomputer as i2c master.
Using this setup for testing has proven really usefull.
Gathering data with those scripts might be a suitable way to develop and test software using higher level concepts, without the need to write code for embedded devices.

\emph{i2cranging.py} contains functions for the master side of I2C communication. Those can either be used from the python PEPL or by other scripts.
\emph{poll\_range.py} contains a convenient method to take continous range readings from the unix shell and is mainly used to generate csv-files with ranging values.
Those csv-files have been used for evaluating the ranging nodes.
